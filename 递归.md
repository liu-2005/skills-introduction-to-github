#### 链表的递归遍历
```java
private void recursion(Node curr, Consumer<Integer> before, Consumer<Integer> after){  
    if (curr == null){  
        return;  
    }  
    before.accept(curr.value);  
    recursion(curr.next, before, after);  
    after.accept(curr.value);  
}  
  
public void loop3(Consumer<Integer> before,  
                  Consumer<Integer> after){  
    recursion(head, before, after);  
}
//调用方：
list.loop3(value ->{  
    System.out.println("before:" + value);  
},value ->{  
    System.out.println("after:" + value);  
});
```
![[递归.png]]

- 链表递归伪代码理解：
![[递归2.png]]
**例2：反向打印字符串**
用递归反向打印字符串，n为字符在整个字符串str中的索引位置
- **递**：n从0开始，每次n + 1, 一直递到n == str.length()-1;
- **归**：从n== str.length()开始扫，从归打印，自然是逆序的

递归关系
$$
f(n) = 
\begin{cases} 
	\text{停止} & n = \text{str.length()} \\
	 f(n+1) & 0 \le n \le \text{str.length()} - 1
 \end{cases}

$$
代码表示：
```java
public class ReversePrintString {  
    public static void f(int n,String str) {  
        if(n == str.length()) {  
            return;  
        }  
        f(n + 1, str);  
        System.out.println(str.charAt(n));  
    }  
    public static void main(String[] args) {  
        f(0, "abcd");  
    }  
}
```
### 多路递归：
例：斐波那契数列
```java
public class E06Fibonacci {  
    public static int f(int n) {  
        if (n == 0){  
            return 0;  
        }  
        if (n == 1){  
            return 1;  
        }  
        return f(n-1) + f(n-2);  
    }  
    public static void main(String[] args) {  
        int f = f(8);  
        System.out.println(f);  
    }  
}//递归次数满足2*f(n+1)-1   
//->可计算时间复杂度 Θ(1.618^n)   --未考虑大数相加
```
递归算法优化：
- Memorization(记忆法)改进
![[优化前.png]]
![[优化后.png]]
```java
import java.util.Arrays;  
  
public class E06Fibonacci {  
    public static int fibonacci(int n) {  
        int[] cache = new int[n + 1];  
        Arrays.fill(cache, -1);  
        cache[0] = 0;  
        cache[1] = 1; //[0, 1, -1, -1, -1]  
        return f(n, cache);  
    }  
    public static int f(int n, int[] cache) {  
        if (cache[n] != -1) {  
            return cache[n];  
        }  
        int x = f(n - 1, cache);  
        int y = f(n - 2, cache);  
        cache[n]= x + y;  
        return cache[n];  
    }  
    public static void main(String[] args) {  
        int f = fibonacci(9 );   
        System.out.println(f);  
    }  
}//改进后的复杂度O(n)
```
- 爆栈问题
例1：
- scala尾递归优化：
```scala
object Main{

	def main(args: Array[String]): Unit = {
	println(sum(3, 0))
	}
	@tailrec
	def sum(n: Long, accumlator: Long): Long = {
	if(n == 1){
		return 1+accumulator
	}
	return sum(n-1, n + accumulator)
	}
}
```
- 根本解决爆栈--递归 ->循环

**主定理求递归的时间复杂度的公式：**
![[主定理.png]]


![[递归时间复杂度.png]]
结论：找a, b，算x,跟c比较,谁大取谁,相等加个logn

**不能用主定理的情况：**
递推式不是n的倍数不能用主定理
![[递归冒泡.png]]

**汉诺塔问题**
![[汉诺塔.png]]
```java
import java.util.LinkedList;  
public class E02HanoiTower {  
    static LinkedList<Integer> a = new LinkedList<>();  
    static LinkedList<Integer> b = new LinkedList<>();  
    static LinkedList<Integer> c = new LinkedList<>();  
    // 3 2 1  
    static void init(int n){  
        for(int i = n; i >= 1 ; i--){  
            a.addLast(i);  
        }  
    }//初始化  
  
    /**  
     *     * @param n 圆盘个数  
     * @param a 源  
     * @param b 借  
     * @param c 目  
     */  
  
    static void move(int n ,LinkedList<Integer> a,  
                     LinkedList<Integer> b,  
                     LinkedList<Integer> c){  
        if(n == 0){  
            return;  
        }  
        move(n - 1, a, c, b);  
        c.addLast(a.removeLast());//中间  
        print();  
        move(n - 1, b, a, c);  
    }  
  
    public static void main(String[] args) {  
        init(4);  
        print();  
        move(4, a, b, c);  
    }  
  
    private static void print() {  
        System.out.println("------------------");  
        System.out.println(a);  
        System.out.println(b);  
        System.out.println(c);  
    }  
}
T(n) = 2T(n-1) + c
时间复杂度：O(2^n)
```
杨辉三角：

优化版1：使用二维数组记忆，时间复杂度$O(n^2)$
```java
public class E03PascalTriangle {  
  
    private static int element(int[][] triangle, int i, int j) {  
        if(triangle[i][j] > 0){  
            return triangle[i][j];   //把这些记录  
        }  
        if(j == 0 || i == j){  
            triangle[i][j] = 1;  
            return 1;//初始化  
        }  
        triangle[i][j] = element(triangle, i - 1, j - 1) + element(triangle, i - 1 , j);  
        return triangle[i][j];  
    }  
  
    private static void printSpace(int n, int i){  
        int num = (n - 1 - i) * 2;  
        for(int j = 0; j < num; j++){  
            System.out.print(" ");  
        }  
    } //打印空格  
  
    public static void print(int n){  
        int[][] triangle = new int[n][];//列后面定义  
        for(int i = 0; i < n; i++){//行  
            triangle[i] = new int[i+1];  
            printSpace(n, i);  
            for(int j = 0; j <= i; j++){  
                System.out.printf("%-4d",element(triangle, i, j));  
            }  
            System.out.println();  
        }  
    }  
    public static void main(String[] args) {  
        print(5);  
    }  
}
```
进一步优化：使用一维数组(动态规划)
```java
public class E03PascalTriangle3 {  
    /*  
    0  0  0  0  0  0  0   初始  
    1  0  0  0  0  0  0   i=1    
    1  2  1  0  0  0  0   i=2    
    1  3  3  1  0  0  0   i=3    
    1  4  6  4  1  0  0   i=4    从右边往左边可以存住数据  
     */    
     private static void printSpace(int n, int i){  
        int num = (n - 1 - i) * 2;  
        for(int j = 0; j < num; j++){  
            System.out.print(" ");  
        }  
    } //打印空格  
  
    public static void print(int n){  
        int[] row= new int[n];//列后面定义  
        for(int i = 0; i < n; i++){//行  
            createRow(row, i);  
            printSpace(n, i);  
            for(int j = 0; j <= i; j++){  
                System.out.printf("%-4d",row[j]);  
            }  
            System.out.println();  
        }  
    }  
  
    private static void createRow(int[] row, int i){  
        if(i == 0){  
            row[0] = 1;  
            return;  
        }  
        for (int j = i; j > 0; j--){  
            row[j] = row[j-1]+row[j];  
        }  
    }//一维数组实现  
    public static void main(String[] args) {  
        print(5);  
    }  
  
}
```